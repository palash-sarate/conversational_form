{"ast":null,"code":"/** @license React v16.5.0\n * schedule.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n    var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n    /**\n     * A scheduling library to allow scheduling work with more granular priority and\n     * control than requestAnimationFrame and requestIdleCallback.\n     * Current TODO items:\n     * X- Pull out the scheduleWork polyfill built into React\n     * X- Initial test coverage\n     * X- Support for multiple callbacks\n     * - Support for two priorities; serial and deferred\n     * - Better test coverage\n     * - Better docblock\n     * - Polish documentation, API\n     */\n    // This is a built-in polyfill for requestIdleCallback. It works by scheduling\n    // a requestAnimationFrame, storing the time for the start of the frame, then\n    // scheduling a postMessage which gets scheduled after paint. Within the\n    // postMessage handler do as much work as possible until time + frame rate.\n    // By separating the idle call into a separate event tick we ensure that\n    // layout, paint and other browser work is counted against the available time.\n    // The frame rate is dynamically adjusted.\n    // We capture a local reference to any global, in case it gets polyfilled after\n    // this module is initially evaluated.\n    // We want to be using a consistent implementation.\n\n    var localDate = Date; // This initialization code may run even on server environments\n    // if a component just imports ReactDOM (e.g. for findDOMNode).\n    // Some environments might not have setTimeout or clearTimeout.\n    // However, we always expect them to be defined on the client.\n    // https://github.com/facebook/react/pull/13088\n\n    var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\n    var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined; // We don't expect either of these to necessarily be defined,\n    // but we will error later if they are missing on the client.\n\n    var localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\n    var localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;\n    var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n    exports.unstable_now = void 0;\n\n    if (hasNativePerformanceNow) {\n      var Performance = performance;\n\n      exports.unstable_now = function () {\n        return Performance.now();\n      };\n    } else {\n      exports.unstable_now = function () {\n        return localDate.now();\n      };\n    }\n\n    exports.unstable_scheduleWork = void 0;\n    exports.unstable_cancelScheduledWork = void 0;\n\n    if (!canUseDOM) {\n      var timeoutIds = new Map();\n\n      exports.unstable_scheduleWork = function (callback, options) {\n        // keeping return type consistent\n        var callbackConfig = {\n          scheduledCallback: callback,\n          timeoutTime: 0,\n          next: null,\n          prev: null\n        };\n        var timeoutId = localSetTimeout(function () {\n          callback({\n            timeRemaining: function () {\n              return Infinity;\n            },\n            didTimeout: false\n          });\n        });\n        timeoutIds.set(callback, timeoutId);\n        return callbackConfig;\n      };\n\n      exports.unstable_cancelScheduledWork = function (callbackId) {\n        var callback = callbackId.scheduledCallback;\n        var timeoutId = timeoutIds.get(callback);\n        timeoutIds.delete(callbackId);\n        localClearTimeout(timeoutId);\n      };\n    } else {\n      {\n        if (typeof console !== 'undefined') {\n          if (typeof localRequestAnimationFrame !== 'function') {\n            console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n          }\n\n          if (typeof localCancelAnimationFrame !== 'function') {\n            console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n          }\n        }\n      }\n      var headOfPendingCallbacksLinkedList = null;\n      var tailOfPendingCallbacksLinkedList = null; // We track what the next soonest timeoutTime is, to be able to quickly tell\n      // if none of the scheduled callbacks have timed out.\n\n      var nextSoonestTimeoutTime = -1;\n      var isIdleScheduled = false;\n      var isAnimationFrameScheduled = false; // requestAnimationFrame does not run when the tab is in the background.\n      // if we're backgrounded we prefer for that work to happen so that the page\n      // continues\tto load in the background.\n      // so we also schedule a 'setTimeout' as a fallback.\n\n      var animationFrameTimeout = 100;\n      var rafID = void 0;\n      var timeoutID = void 0;\n\n      var scheduleAnimationFrameWithFallbackSupport = function (callback) {\n        // schedule rAF and also a setTimeout\n        rafID = localRequestAnimationFrame(function (timestamp) {\n          // cancel the setTimeout\n          localClearTimeout(timeoutID);\n          callback(timestamp);\n        });\n        timeoutID = localSetTimeout(function () {\n          // cancel the requestAnimationFrame\n          localCancelAnimationFrame(rafID);\n          callback(exports.unstable_now());\n        }, animationFrameTimeout);\n      };\n\n      var frameDeadline = 0; // We start out assuming that we run at 30fps but then the heuristic tracking\n      // will adjust this value to a faster fps if we get more frequent animation\n      // frames.\n\n      var previousFrameTime = 33;\n      var activeFrameTime = 33;\n      var frameDeadlineObject = {\n        didTimeout: false,\n        timeRemaining: function () {\n          var remaining = frameDeadline - exports.unstable_now();\n          return remaining > 0 ? remaining : 0;\n        }\n      };\n      /**\n       * Handles the case where a callback errors:\n       * - don't catch the error, because this changes debugging behavior\n       * - do start a new postMessage callback, to call any remaining callbacks,\n       * - but only if there is an error, so there is not extra overhead.\n       */\n\n      var callUnsafely = function (callbackConfig, arg) {\n        var callback = callbackConfig.scheduledCallback;\n        var finishedCalling = false;\n\n        try {\n          callback(arg);\n          finishedCalling = true;\n        } finally {\n          // always remove it from linked list\n          exports.unstable_cancelScheduledWork(callbackConfig);\n\n          if (!finishedCalling) {\n            // an error must have been thrown\n            isIdleScheduled = true;\n            window.postMessage(messageKey, '*');\n          }\n        }\n      };\n      /**\n       * Checks for timed out callbacks, runs them, and then checks again to see if\n       * any more have timed out.\n       * Keeps doing this until there are none which have currently timed out.\n       */\n\n\n      var callTimedOutCallbacks = function () {\n        if (headOfPendingCallbacksLinkedList === null) {\n          return;\n        }\n\n        var currentTime = exports.unstable_now(); // TODO: this would be more efficient if deferred callbacks are stored in\n        // min heap.\n        // Or in a linked list with links for both timeoutTime order and insertion\n        // order.\n        // For now an easy compromise is the current approach:\n        // Keep a pointer to the soonest timeoutTime, and check that first.\n        // If it has not expired, we can skip traversing the whole list.\n        // If it has expired, then we step through all the callbacks.\n\n        if (nextSoonestTimeoutTime === -1 || nextSoonestTimeoutTime > currentTime) {\n          // We know that none of them have timed out yet.\n          return;\n        } // NOTE: we intentionally wait to update the nextSoonestTimeoutTime until\n        // after successfully calling any timed out callbacks.\n        // If a timed out callback throws an error, we could get stuck in a state\n        // where the nextSoonestTimeoutTime was set wrong.\n\n\n        var updatedNextSoonestTimeoutTime = -1; // we will update nextSoonestTimeoutTime below\n\n        var timedOutCallbacks = []; // iterate once to find timed out callbacks and find nextSoonestTimeoutTime\n\n        var currentCallbackConfig = headOfPendingCallbacksLinkedList;\n\n        while (currentCallbackConfig !== null) {\n          var _timeoutTime = currentCallbackConfig.timeoutTime;\n\n          if (_timeoutTime !== -1 && _timeoutTime <= currentTime) {\n            // it has timed out!\n            timedOutCallbacks.push(currentCallbackConfig);\n          } else {\n            if (_timeoutTime !== -1 && (updatedNextSoonestTimeoutTime === -1 || _timeoutTime < updatedNextSoonestTimeoutTime)) {\n              updatedNextSoonestTimeoutTime = _timeoutTime;\n            }\n          }\n\n          currentCallbackConfig = currentCallbackConfig.next;\n        }\n\n        if (timedOutCallbacks.length > 0) {\n          frameDeadlineObject.didTimeout = true;\n\n          for (var i = 0, len = timedOutCallbacks.length; i < len; i++) {\n            callUnsafely(timedOutCallbacks[i], frameDeadlineObject);\n          }\n        } // NOTE: we intentionally wait to update the nextSoonestTimeoutTime until\n        // after successfully calling any timed out callbacks.\n\n\n        nextSoonestTimeoutTime = updatedNextSoonestTimeoutTime;\n      }; // We use the postMessage trick to defer idle work until after the repaint.\n\n\n      var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n\n      var idleTick = function (event) {\n        if (event.source !== window || event.data !== messageKey) {\n          return;\n        }\n\n        isIdleScheduled = false;\n\n        if (headOfPendingCallbacksLinkedList === null) {\n          return;\n        } // First call anything which has timed out, until we have caught up.\n\n\n        callTimedOutCallbacks();\n        var currentTime = exports.unstable_now(); // Next, as long as we have idle time, try calling more callbacks.\n\n        while (frameDeadline - currentTime > 0 && headOfPendingCallbacksLinkedList !== null) {\n          var latestCallbackConfig = headOfPendingCallbacksLinkedList;\n          frameDeadlineObject.didTimeout = false; // callUnsafely will remove it from the head of the linked list\n\n          callUnsafely(latestCallbackConfig, frameDeadlineObject);\n          currentTime = exports.unstable_now();\n        }\n\n        if (headOfPendingCallbacksLinkedList !== null) {\n          if (!isAnimationFrameScheduled) {\n            // Schedule another animation callback so we retry later.\n            isAnimationFrameScheduled = true;\n            scheduleAnimationFrameWithFallbackSupport(animationTick);\n          }\n        }\n      }; // Assumes that we have addEventListener in this environment. Might need\n      // something better for old IE.\n\n\n      window.addEventListener('message', idleTick, false);\n\n      var animationTick = function (rafTime) {\n        isAnimationFrameScheduled = false;\n        var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n\n        if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n          if (nextFrameTime < 8) {\n            // Defensive coding. We don't support higher frame rates than 120hz.\n            // If we get lower than that, it is probably a bug.\n            nextFrameTime = 8;\n          } // If one frame goes long, then the next one can be short to catch up.\n          // If two frames are short in a row, then that's an indication that we\n          // actually have a higher frame rate than what we're currently optimizing.\n          // We adjust our heuristic dynamically accordingly. For example, if we're\n          // running on 120hz display or 90hz VR display.\n          // Take the max of the two in case one of them was an anomaly due to\n          // missed frame deadlines.\n\n\n          activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n        } else {\n          previousFrameTime = nextFrameTime;\n        }\n\n        frameDeadline = rafTime + activeFrameTime;\n\n        if (!isIdleScheduled) {\n          isIdleScheduled = true;\n          window.postMessage(messageKey, '*');\n        }\n      };\n\n      exports.unstable_scheduleWork = function (callback, options)\n      /* CallbackConfigType */\n      {\n        var timeoutTime = -1;\n\n        if (options != null && typeof options.timeout === 'number') {\n          timeoutTime = exports.unstable_now() + options.timeout;\n        }\n\n        if (nextSoonestTimeoutTime === -1 || timeoutTime !== -1 && timeoutTime < nextSoonestTimeoutTime) {\n          nextSoonestTimeoutTime = timeoutTime;\n        }\n\n        var scheduledCallbackConfig = {\n          scheduledCallback: callback,\n          timeoutTime: timeoutTime,\n          prev: null,\n          next: null\n        };\n\n        if (headOfPendingCallbacksLinkedList === null) {\n          // Make this callback the head and tail of our list\n          headOfPendingCallbacksLinkedList = scheduledCallbackConfig;\n          tailOfPendingCallbacksLinkedList = scheduledCallbackConfig;\n        } else {\n          // Add latest callback as the new tail of the list\n          scheduledCallbackConfig.prev = tailOfPendingCallbacksLinkedList; // renaming for clarity\n\n          var oldTailOfPendingCallbacksLinkedList = tailOfPendingCallbacksLinkedList;\n\n          if (oldTailOfPendingCallbacksLinkedList !== null) {\n            oldTailOfPendingCallbacksLinkedList.next = scheduledCallbackConfig;\n          }\n\n          tailOfPendingCallbacksLinkedList = scheduledCallbackConfig;\n        }\n\n        if (!isAnimationFrameScheduled) {\n          // If rAF didn't already schedule one, we need to schedule a frame.\n          // TODO: If this rAF doesn't materialize because the browser throttles, we\n          // might want to still have setTimeout trigger scheduleWork as a backup to ensure\n          // that we keep performing work.\n          isAnimationFrameScheduled = true;\n          scheduleAnimationFrameWithFallbackSupport(animationTick);\n        }\n\n        return scheduledCallbackConfig;\n      };\n\n      exports.unstable_cancelScheduledWork = function (callbackConfig\n      /* CallbackConfigType */\n      ) {\n        if (callbackConfig.prev === null && headOfPendingCallbacksLinkedList !== callbackConfig) {\n          // this callbackConfig has already been cancelled.\n          // cancelScheduledWork should be idempotent, a no-op after first call.\n          return;\n        }\n        /**\n         * There are four possible cases:\n         * - Head/nodeToRemove/Tail -> null\n         *   In this case we set Head and Tail to null.\n         * - Head -> ... middle nodes... -> Tail/nodeToRemove\n         *   In this case we point the middle.next to null and put middle as the new\n         *   Tail.\n         * - Head/nodeToRemove -> ...middle nodes... -> Tail\n         *   In this case we point the middle.prev at null and move the Head to\n         *   middle.\n         * - Head -> ... ?some nodes ... -> nodeToRemove -> ... ?some nodes ... -> Tail\n         *   In this case we point the Head.next to the Tail and the Tail.prev to\n         *   the Head.\n         */\n\n\n        var next = callbackConfig.next;\n        var prev = callbackConfig.prev;\n        callbackConfig.next = null;\n        callbackConfig.prev = null;\n\n        if (next !== null) {\n          // we have a next\n          if (prev !== null) {\n            // we have a prev\n            // callbackConfig is somewhere in the middle of a list of 3 or more nodes.\n            prev.next = next;\n            next.prev = prev;\n            return;\n          } else {\n            // there is a next but not a previous one;\n            // callbackConfig is the head of a list of 2 or more other nodes.\n            next.prev = null;\n            headOfPendingCallbacksLinkedList = next;\n            return;\n          }\n        } else {\n          // there is no next callback config; this must the tail of the list\n          if (prev !== null) {\n            // we have a prev\n            // callbackConfig is the tail of a list of 2 or more other nodes.\n            prev.next = null;\n            tailOfPendingCallbacksLinkedList = prev;\n            return;\n          } else {\n            // there is no previous callback config;\n            // callbackConfig is the only thing in the linked list,\n            // so both head and tail point to it.\n            headOfPendingCallbacksLinkedList = null;\n            tailOfPendingCallbacksLinkedList = null;\n            return;\n          }\n        }\n      };\n    }\n  })();\n}","map":{"version":3,"sources":["/media/palash/Data/xfinito/React projects/react-conversational-form-example/node_modules/schedule/cjs/schedule.development.js"],"names":["process","env","NODE_ENV","Object","defineProperty","exports","value","canUseDOM","window","document","createElement","localDate","Date","localSetTimeout","setTimeout","undefined","localClearTimeout","clearTimeout","localRequestAnimationFrame","requestAnimationFrame","localCancelAnimationFrame","cancelAnimationFrame","hasNativePerformanceNow","performance","now","unstable_now","Performance","unstable_scheduleWork","unstable_cancelScheduledWork","timeoutIds","Map","callback","options","callbackConfig","scheduledCallback","timeoutTime","next","prev","timeoutId","timeRemaining","Infinity","didTimeout","set","callbackId","get","delete","console","error","headOfPendingCallbacksLinkedList","tailOfPendingCallbacksLinkedList","nextSoonestTimeoutTime","isIdleScheduled","isAnimationFrameScheduled","animationFrameTimeout","rafID","timeoutID","scheduleAnimationFrameWithFallbackSupport","timestamp","frameDeadline","previousFrameTime","activeFrameTime","frameDeadlineObject","remaining","callUnsafely","arg","finishedCalling","postMessage","messageKey","callTimedOutCallbacks","currentTime","updatedNextSoonestTimeoutTime","timedOutCallbacks","currentCallbackConfig","_timeoutTime","push","length","i","len","Math","random","toString","slice","idleTick","event","source","data","latestCallbackConfig","animationTick","addEventListener","rafTime","nextFrameTime","timeout","scheduledCallbackConfig","oldTailOfPendingCallbacksLinkedList"],"mappings":"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","sourcesContent":["/** @license React v16.5.0\n * schedule.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\n/**\n * A scheduling library to allow scheduling work with more granular priority and\n * control than requestAnimationFrame and requestIdleCallback.\n * Current TODO items:\n * X- Pull out the scheduleWork polyfill built into React\n * X- Initial test coverage\n * X- Support for multiple callbacks\n * - Support for two priorities; serial and deferred\n * - Better test coverage\n * - Better docblock\n * - Polish documentation, API\n */\n\n// This is a built-in polyfill for requestIdleCallback. It works by scheduling\n// a requestAnimationFrame, storing the time for the start of the frame, then\n// scheduling a postMessage which gets scheduled after paint. Within the\n// postMessage handler do as much work as possible until time + frame rate.\n// By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\n// We capture a local reference to any global, in case it gets polyfilled after\n// this module is initially evaluated.\n// We want to be using a consistent implementation.\nvar localDate = Date;\n\n// This initialization code may run even on server environments\n// if a component just imports ReactDOM (e.g. for findDOMNode).\n// Some environments might not have setTimeout or clearTimeout.\n// However, we always expect them to be defined on the client.\n// https://github.com/facebook/react/pull/13088\nvar localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\nvar localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\n\n// We don't expect either of these to necessarily be defined,\n// but we will error later if they are missing on the client.\nvar localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\nvar localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;\n\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\nexports.unstable_now = void 0;\nif (hasNativePerformanceNow) {\n  var Performance = performance;\n  exports.unstable_now = function () {\n    return Performance.now();\n  };\n} else {\n  exports.unstable_now = function () {\n    return localDate.now();\n  };\n}\n\nexports.unstable_scheduleWork = void 0;\nexports.unstable_cancelScheduledWork = void 0;\n\nif (!canUseDOM) {\n  var timeoutIds = new Map();\n\n  exports.unstable_scheduleWork = function (callback, options) {\n    // keeping return type consistent\n    var callbackConfig = {\n      scheduledCallback: callback,\n      timeoutTime: 0,\n      next: null,\n      prev: null\n    };\n    var timeoutId = localSetTimeout(function () {\n      callback({\n        timeRemaining: function () {\n          return Infinity;\n        },\n\n        didTimeout: false\n      });\n    });\n    timeoutIds.set(callback, timeoutId);\n    return callbackConfig;\n  };\n  exports.unstable_cancelScheduledWork = function (callbackId) {\n    var callback = callbackId.scheduledCallback;\n    var timeoutId = timeoutIds.get(callback);\n    timeoutIds.delete(callbackId);\n    localClearTimeout(timeoutId);\n  };\n} else {\n  {\n    if (typeof console !== 'undefined') {\n      if (typeof localRequestAnimationFrame !== 'function') {\n        console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n      }\n      if (typeof localCancelAnimationFrame !== 'function') {\n        console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n      }\n    }\n  }\n\n  var headOfPendingCallbacksLinkedList = null;\n  var tailOfPendingCallbacksLinkedList = null;\n\n  // We track what the next soonest timeoutTime is, to be able to quickly tell\n  // if none of the scheduled callbacks have timed out.\n  var nextSoonestTimeoutTime = -1;\n\n  var isIdleScheduled = false;\n  var isAnimationFrameScheduled = false;\n\n  // requestAnimationFrame does not run when the tab is in the background.\n  // if we're backgrounded we prefer for that work to happen so that the page\n  // continues\tto load in the background.\n  // so we also schedule a 'setTimeout' as a fallback.\n  var animationFrameTimeout = 100;\n  var rafID = void 0;\n  var timeoutID = void 0;\n  var scheduleAnimationFrameWithFallbackSupport = function (callback) {\n    // schedule rAF and also a setTimeout\n    rafID = localRequestAnimationFrame(function (timestamp) {\n      // cancel the setTimeout\n      localClearTimeout(timeoutID);\n      callback(timestamp);\n    });\n    timeoutID = localSetTimeout(function () {\n      // cancel the requestAnimationFrame\n      localCancelAnimationFrame(rafID);\n      callback(exports.unstable_now());\n    }, animationFrameTimeout);\n  };\n\n  var frameDeadline = 0;\n  // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n\n  var frameDeadlineObject = {\n    didTimeout: false,\n    timeRemaining: function () {\n      var remaining = frameDeadline - exports.unstable_now();\n      return remaining > 0 ? remaining : 0;\n    }\n  };\n\n  /**\n   * Handles the case where a callback errors:\n   * - don't catch the error, because this changes debugging behavior\n   * - do start a new postMessage callback, to call any remaining callbacks,\n   * - but only if there is an error, so there is not extra overhead.\n   */\n  var callUnsafely = function (callbackConfig, arg) {\n    var callback = callbackConfig.scheduledCallback;\n    var finishedCalling = false;\n    try {\n      callback(arg);\n      finishedCalling = true;\n    } finally {\n      // always remove it from linked list\n      exports.unstable_cancelScheduledWork(callbackConfig);\n\n      if (!finishedCalling) {\n        // an error must have been thrown\n        isIdleScheduled = true;\n        window.postMessage(messageKey, '*');\n      }\n    }\n  };\n\n  /**\n   * Checks for timed out callbacks, runs them, and then checks again to see if\n   * any more have timed out.\n   * Keeps doing this until there are none which have currently timed out.\n   */\n  var callTimedOutCallbacks = function () {\n    if (headOfPendingCallbacksLinkedList === null) {\n      return;\n    }\n\n    var currentTime = exports.unstable_now();\n    // TODO: this would be more efficient if deferred callbacks are stored in\n    // min heap.\n    // Or in a linked list with links for both timeoutTime order and insertion\n    // order.\n    // For now an easy compromise is the current approach:\n    // Keep a pointer to the soonest timeoutTime, and check that first.\n    // If it has not expired, we can skip traversing the whole list.\n    // If it has expired, then we step through all the callbacks.\n    if (nextSoonestTimeoutTime === -1 || nextSoonestTimeoutTime > currentTime) {\n      // We know that none of them have timed out yet.\n      return;\n    }\n    // NOTE: we intentionally wait to update the nextSoonestTimeoutTime until\n    // after successfully calling any timed out callbacks.\n    // If a timed out callback throws an error, we could get stuck in a state\n    // where the nextSoonestTimeoutTime was set wrong.\n    var updatedNextSoonestTimeoutTime = -1; // we will update nextSoonestTimeoutTime below\n    var timedOutCallbacks = [];\n\n    // iterate once to find timed out callbacks and find nextSoonestTimeoutTime\n    var currentCallbackConfig = headOfPendingCallbacksLinkedList;\n    while (currentCallbackConfig !== null) {\n      var _timeoutTime = currentCallbackConfig.timeoutTime;\n      if (_timeoutTime !== -1 && _timeoutTime <= currentTime) {\n        // it has timed out!\n        timedOutCallbacks.push(currentCallbackConfig);\n      } else {\n        if (_timeoutTime !== -1 && (updatedNextSoonestTimeoutTime === -1 || _timeoutTime < updatedNextSoonestTimeoutTime)) {\n          updatedNextSoonestTimeoutTime = _timeoutTime;\n        }\n      }\n      currentCallbackConfig = currentCallbackConfig.next;\n    }\n\n    if (timedOutCallbacks.length > 0) {\n      frameDeadlineObject.didTimeout = true;\n      for (var i = 0, len = timedOutCallbacks.length; i < len; i++) {\n        callUnsafely(timedOutCallbacks[i], frameDeadlineObject);\n      }\n    }\n\n    // NOTE: we intentionally wait to update the nextSoonestTimeoutTime until\n    // after successfully calling any timed out callbacks.\n    nextSoonestTimeoutTime = updatedNextSoonestTimeoutTime;\n  };\n\n  // We use the postMessage trick to defer idle work until after the repaint.\n  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n  var idleTick = function (event) {\n    if (event.source !== window || event.data !== messageKey) {\n      return;\n    }\n    isIdleScheduled = false;\n\n    if (headOfPendingCallbacksLinkedList === null) {\n      return;\n    }\n\n    // First call anything which has timed out, until we have caught up.\n    callTimedOutCallbacks();\n\n    var currentTime = exports.unstable_now();\n    // Next, as long as we have idle time, try calling more callbacks.\n    while (frameDeadline - currentTime > 0 && headOfPendingCallbacksLinkedList !== null) {\n      var latestCallbackConfig = headOfPendingCallbacksLinkedList;\n      frameDeadlineObject.didTimeout = false;\n      // callUnsafely will remove it from the head of the linked list\n      callUnsafely(latestCallbackConfig, frameDeadlineObject);\n      currentTime = exports.unstable_now();\n    }\n    if (headOfPendingCallbacksLinkedList !== null) {\n      if (!isAnimationFrameScheduled) {\n        // Schedule another animation callback so we retry later.\n        isAnimationFrameScheduled = true;\n        scheduleAnimationFrameWithFallbackSupport(animationTick);\n      }\n    }\n  };\n  // Assumes that we have addEventListener in this environment. Might need\n  // something better for old IE.\n  window.addEventListener('message', idleTick, false);\n\n  var animationTick = function (rafTime) {\n    isAnimationFrameScheduled = false;\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If we get lower than that, it is probably a bug.\n        nextFrameTime = 8;\n      }\n      // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n    frameDeadline = rafTime + activeFrameTime;\n    if (!isIdleScheduled) {\n      isIdleScheduled = true;\n      window.postMessage(messageKey, '*');\n    }\n  };\n\n  exports.unstable_scheduleWork = function (callback, options) /* CallbackConfigType */{\n    var timeoutTime = -1;\n    if (options != null && typeof options.timeout === 'number') {\n      timeoutTime = exports.unstable_now() + options.timeout;\n    }\n    if (nextSoonestTimeoutTime === -1 || timeoutTime !== -1 && timeoutTime < nextSoonestTimeoutTime) {\n      nextSoonestTimeoutTime = timeoutTime;\n    }\n\n    var scheduledCallbackConfig = {\n      scheduledCallback: callback,\n      timeoutTime: timeoutTime,\n      prev: null,\n      next: null\n    };\n    if (headOfPendingCallbacksLinkedList === null) {\n      // Make this callback the head and tail of our list\n      headOfPendingCallbacksLinkedList = scheduledCallbackConfig;\n      tailOfPendingCallbacksLinkedList = scheduledCallbackConfig;\n    } else {\n      // Add latest callback as the new tail of the list\n      scheduledCallbackConfig.prev = tailOfPendingCallbacksLinkedList;\n      // renaming for clarity\n      var oldTailOfPendingCallbacksLinkedList = tailOfPendingCallbacksLinkedList;\n      if (oldTailOfPendingCallbacksLinkedList !== null) {\n        oldTailOfPendingCallbacksLinkedList.next = scheduledCallbackConfig;\n      }\n      tailOfPendingCallbacksLinkedList = scheduledCallbackConfig;\n    }\n\n    if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger scheduleWork as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      scheduleAnimationFrameWithFallbackSupport(animationTick);\n    }\n    return scheduledCallbackConfig;\n  };\n\n  exports.unstable_cancelScheduledWork = function (callbackConfig /* CallbackConfigType */\n  ) {\n    if (callbackConfig.prev === null && headOfPendingCallbacksLinkedList !== callbackConfig) {\n      // this callbackConfig has already been cancelled.\n      // cancelScheduledWork should be idempotent, a no-op after first call.\n      return;\n    }\n\n    /**\n     * There are four possible cases:\n     * - Head/nodeToRemove/Tail -> null\n     *   In this case we set Head and Tail to null.\n     * - Head -> ... middle nodes... -> Tail/nodeToRemove\n     *   In this case we point the middle.next to null and put middle as the new\n     *   Tail.\n     * - Head/nodeToRemove -> ...middle nodes... -> Tail\n     *   In this case we point the middle.prev at null and move the Head to\n     *   middle.\n     * - Head -> ... ?some nodes ... -> nodeToRemove -> ... ?some nodes ... -> Tail\n     *   In this case we point the Head.next to the Tail and the Tail.prev to\n     *   the Head.\n     */\n    var next = callbackConfig.next;\n    var prev = callbackConfig.prev;\n    callbackConfig.next = null;\n    callbackConfig.prev = null;\n    if (next !== null) {\n      // we have a next\n\n      if (prev !== null) {\n        // we have a prev\n\n        // callbackConfig is somewhere in the middle of a list of 3 or more nodes.\n        prev.next = next;\n        next.prev = prev;\n        return;\n      } else {\n        // there is a next but not a previous one;\n        // callbackConfig is the head of a list of 2 or more other nodes.\n        next.prev = null;\n        headOfPendingCallbacksLinkedList = next;\n        return;\n      }\n    } else {\n      // there is no next callback config; this must the tail of the list\n\n      if (prev !== null) {\n        // we have a prev\n\n        // callbackConfig is the tail of a list of 2 or more other nodes.\n        prev.next = null;\n        tailOfPendingCallbacksLinkedList = prev;\n        return;\n      } else {\n        // there is no previous callback config;\n        // callbackConfig is the only thing in the linked list,\n        // so both head and tail point to it.\n        headOfPendingCallbacksLinkedList = null;\n        tailOfPendingCallbacksLinkedList = null;\n        return;\n      }\n    }\n  };\n}\n  })();\n}\n"]},"metadata":{},"sourceType":"script"}